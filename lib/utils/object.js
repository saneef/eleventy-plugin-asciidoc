// @ts-check

/**
 * Return a copy of the object, filtered to only have values for the allowed keys (or array of valid keys). Alternatively accepts a predicate indicating which keys to pick.
 *
 * @param      {object}  obj  The object
 * @param      {(key: string, value: any, obj: object ) => boolean | Array<string>}  keys    The keys
 * @return     {object}  Copy of the object with filtered values
 */
function pick(obj, keys = (_k, v) => Boolean(v)) {
  if (Array.isArray(keys)) {
    return pick(obj, (key) => keys.includes(key));
  }

  return Object.keys(obj).reduce((acc, k) => {
    if (keys(k, obj[k], obj)) {
      return {
        [k]: obj[k],
        ...acc,
      };
    }

    return acc;
  }, {});
}

/**
 * Picks keys with matching prefix and removes prefix from keys
 *
 * @param      {object}  obj  The objec
 * @param      {string}  prefix  The key prefix
 * @return     {object}  Copy of the object with filtered values
 */
function pickByKeyPrefix(obj, prefix) {
  return pick(obj, (k) => k.startsWith(prefix));
}

/**
 * Creates a copy of of the object keys generated by running mapKey
 *
 * @param      {object}    obj                 The object
 * @param      {(k: string, v: any)=> string}  [mapKey=(k)=>k]  The function to map the keys
 * @return     {object}    { Copy of the object with mapped keys }
 */
function mapKeys(obj, mapKey = (k) => k) {
  return Object.entries(obj).reduce((acc, [k, v]) => {
    const newKey = mapKey(k, v);
    return {
      [newKey]: v,
      ...acc,
    };
  }, {});
}

module.exports = {
  pickByKeyPrefix,
  pick,
  mapKeys,
};
